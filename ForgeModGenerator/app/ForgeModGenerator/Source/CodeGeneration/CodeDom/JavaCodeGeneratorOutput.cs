using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Globalization;
using System.Text;

namespace ForgeModGenerator.CodeGeneration.CodeDom
{
    public partial class JavaCodeGenerator : ICodeGenerator
    {
        private void OutputOperator(CodeBinaryOperatorType op) => output.Write(binaryOperatorChars[op]);
        private void OutputType(CodeTypeReference typeRef) => output.Write(GetTypeOutput(typeRef));
        private void OutputIdentifier(string ident) => output.Write(CreateEscapedIdentifier(ident));

        private void OutputGenerationMessage()
        {
            output.WriteLine("//------------------------------------------------------------------------------");
            output.WriteLine("// This file was autogenerated");
            output.WriteLine("// Any changes can be lost when file will be regenerated ");
            output.WriteLine("//------------------------------------------------------------------------------");
            output.WriteLine("");
        }

        private void OutputStartingBrace()
        {
            if (options.BracingStyle == "C")
            {
                output.WriteLine("");
                output.WriteLine("{");
            }
            else
            {
                output.WriteLine(" {");
            }
        }

        private void OutputVTableModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.VTableMask)
            {
                case MemberAttributes.New:
                    output.Write("new ");
                    break;
            }
        }

        private void OutputMemberAccessModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.AccessMask)
            {
                case MemberAttributes.Family:
                case MemberAttributes.FamilyOrAssembly:
                    output.Write("protected");
                    break;
                case MemberAttributes.Private:
                    output.Write("private ");
                    break;
                case MemberAttributes.Public:
                    output.Write("public ");
                    break;
            }
        }

        private void OutputMemberScopeModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.ScopeMask)
            {
                case MemberAttributes.Abstract:
                    output.Write("abstract ");
                    break;
                case MemberAttributes.Static:
                    output.Write("static ");
                    break;
                case MemberAttributes.Final:
                    output.Write("final ");
                    break;
                default:
                    break;
            }
        }

        private void OutputFieldScopeModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.ScopeMask)
            {
                case MemberAttributes.Const:
                case MemberAttributes.Final:
                    output.Write("final ");
                    break;
                case MemberAttributes.Static:
                    output.Write("static ");
                    break;
                default:
                    break;
            }
        }

        private void OutputTypeNamePair(CodeTypeReference typeRef, string name)
        {
            OutputType(typeRef);
            output.Write(" ");
            OutputIdentifier(name);
        }

        private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems = false)
        {
            bool first = true;
            IEnumerator en = expressions.GetEnumerator();
            Indent++;
            while (en.MoveNext())
            {
                if (!first)
                {
                    if (newlineBetweenItems)
                    {
                        ContinueOnNewLine(",");
                    }
                    else
                    {
                        output.Write(", ");
                    }
                }
                else
                {
                    first = false;
                }
                ((ICodeGenerator)this).GenerateCodeFromExpression((CodeExpression)en.Current, output.InnerWriter, options);
            }
            Indent--;
        }

        private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
        {
            bool first = true;
            bool multiline = parameters.Count > ParameterMultilineThreshold;
            if (multiline)
            {
                Indent += 3;
            }
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext())
            {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                if (!first)
                {
                    output.Write(", ");
                }
                else
                {
                    first = false;
                }
                if (multiline)
                {
                    ContinueOnNewLine("");
                }
                GenerateExpression(current);
            }
            if (multiline)
            {
                Indent -= 3;
            }
        }

        private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
        {
            if (typeParameters.Count == 0)
            {
                return;
            }

            output.Write('<');
            bool first = true;
            for (int i = 0; i < typeParameters.Count; i++)
            {
                if (!first)
                {
                    output.Write(", ");
                }
                else
                {
                    first = false;
                }

                if (typeParameters[i].CustomAttributes.Count > 0)
                {
                    GenerateAttributes(typeParameters[i].CustomAttributes, null, true);
                    output.Write(' ');
                }
                output.Write(typeParameters[i].Name);
            }
            output.Write('>');
        }

        // returns the type name without any array declaration.
        private string GetBaseTypeOutput(CodeTypeReference typeRef)
        {
            string s = typeRef.BaseType;
            if (s.Length == 0)
            {
                return "void";
            }

            string lowerCaseString = s.ToLower(CultureInfo.InvariantCulture).Trim();
            switch (lowerCaseString)
            {
                case "system.int16":
                    s = "short";
                    break;
                case "system.int32":
                    s = "int";
                    break;
                case "system.int64":
                    s = "long";
                    break;
                case "system.string":
                    s = "String";
                    break;
                case "system.object":
                    s = "Object";
                    break;
                case "system.boolean":
                    s = "boolean";
                    break;
                case "system.void":
                    s = "void";
                    break;
                case "system.char":
                    s = "char";
                    break;
                case "system.byte":
                    s = "byte";
                    break;
                case "system.single":
                    s = "float";
                    break;
                case "system.double":
                    s = "double";
                    break;
                default:
                    // replace + with . for nested classes
                    StringBuilder sb = new StringBuilder(s.Length + 10);
                    if ((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0)
                    {
                        sb.Append("global::");
                    }

                    string baseType = typeRef.BaseType;
                    int lastIndex = 0;
                    int currentTypeArgStart = 0;
                    for (int i = 0; i < baseType.Length; i++)
                    {
                        switch (baseType[i])
                        {
                            case '+':
                            case '.':
                                sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex, i - lastIndex)));
                                sb.Append('.');
                                i++;
                                lastIndex = i;
                                break;

                            case '`':
                                sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex, i - lastIndex)));
                                i++; // skip the '
                                int numTypeArgs = 0;
                                while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <= '9')
                                {
                                    numTypeArgs = numTypeArgs * 10 + (baseType[i] - '0');
                                    i++;
                                }

                                GetTypeArgumentsOutput(typeRef.TypeArguments, currentTypeArgStart, numTypeArgs, sb);
                                currentTypeArgStart += numTypeArgs;

                                // Arity can be in the middle of a nested type name, so we might have a . or + after it.
                                // Skip it if so.
                                if (i < baseType.Length && (baseType[i] == '+' || baseType[i] == '.'))
                                {
                                    sb.Append('.');
                                    i++;
                                }

                                lastIndex = i;
                                break;
                        }
                    }

                    if (lastIndex < baseType.Length)
                    {
                        sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));
                    }
                    return sb.ToString();
            }
            return s;
        }

        private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
        {
            StringBuilder sb = new StringBuilder(128);
            GetTypeArgumentsOutput(typeArguments, 0, typeArguments.Count, sb);
            return sb.ToString();
        }

        private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
        {
            sb.Append('<');
            bool first = true;
            for (int i = start; i < start + length; i++)
            {
                if (!first)
                {
                    sb.Append(", ");
                }
                else
                {
                    first = false;
                }

                // it's possible that we call GetTypeArgumentsOutput with an empty typeArguments collection.  This is the case
                // for open types, so we want to just output the brackets and commas.
                if (i < typeArguments.Count)
                {
                    sb.Append(GetTypeOutput(typeArguments[i]));
                }
            }
            sb.Append('>');
        }

        public string GetTypeOutput(CodeTypeReference typeRef)
        {
            string s = string.Empty;
            CodeTypeReference baseTypeRef = typeRef;
            while (baseTypeRef.ArrayElementType != null)
            {
                baseTypeRef = baseTypeRef.ArrayElementType;
            }
            s += GetBaseTypeOutput(baseTypeRef);

            while (typeRef != null && typeRef.ArrayRank > 0)
            {
                char[] results = new char[typeRef.ArrayRank + 1];
                results[0] = '[';
                results[typeRef.ArrayRank] = ']';
                for (int i = 1; i < typeRef.ArrayRank; i++)
                {
                    results[i] = ',';
                }
                s += new string(results);
                typeRef = typeRef.ArrayElementType;
            }
            return s;
        }
    }
}
