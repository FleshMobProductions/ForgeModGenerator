using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace ForgeModGenerator.CodeGeneration.CodeDom
{
    public partial class JavaCodeGenerator : ICodeGenerator
    {
        private void OutputOperator(CodeBinaryOperatorType op) => output.Write(binaryOperatorChars[op]);
        private void OutputType(CodeTypeReference typeRef) => output.Write(GetTypeOutput(typeRef));
        private void OutputIdentifier(string ident) => output.Write(CreateEscapedIdentifier(ident));

        private void OutputGenerationMessage()
        {
            output.WriteLine("//------------------------------------------------------------------------------");
            output.WriteLine("// This file was autogenerated");
            output.WriteLine("// When the file is regenerated, any changes will be lost");
            output.WriteLine("//------------------------------------------------------------------------------");
            output.WriteLine("");
        }

        private void OutputStartingBrace()
        {
            if (options.BracingStyle == "C")
            {
                output.WriteLine("");
                output.WriteLine("{");
            }
            else
            {
                output.WriteLine(" {");
            }
        }

        private void OutputVTableModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.VTableMask)
            {
                case MemberAttributes.New:
                    output.Write("new ");
                    break;
            }
        }

        private void OutputMemberAccessModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.AccessMask)
            {
                case MemberAttributes.Private:
                    output.Write("private ");
                    break;
                case MemberAttributes.Public:
                    output.Write("public ");
                    break;
                case MemberAttributes.Family:
                case MemberAttributes.FamilyOrAssembly:
                case MemberAttributes.FamilyAndAssembly:
                    output.Write("protected ");
                    break;
                default:
                    break;
            }
        }

        private void OutputMemberScopeModifier(MemberAttributes attributes)
        {
            attributes &= MemberAttributes.ScopeMask;
            bool canBeAbstract = true;
            if (attributes.HasFlag(MemberAttributes.Static))
            {
                output.Write("static ");
                canBeAbstract = false;
            }
            if (attributes != MemberAttributes.ScopeMask && attributes.HasFlag(MemberAttributes.Final))
            {
                output.Write("final ");
                canBeAbstract = false;
            }
            if (canBeAbstract && attributes.HasFlag(MemberAttributes.Abstract))
            {
                output.Write("abstract ");
            }
        }

        private void OutputFieldScopeModifier(MemberAttributes attributes)
        {
            attributes &= MemberAttributes.ScopeMask;
            if (attributes.HasFlag(MemberAttributes.Static))
            {
                output.Write("static ");
            }
            if (attributes != MemberAttributes.ScopeMask
                && (attributes.HasFlag(MemberAttributes.Final) || attributes.HasFlag(MemberAttributes.Const)))
            {
                output.Write("final ");
            }
        }

        private void OutputTypeNamePair(CodeTypeReference typeRef, string name)
        {
            OutputType(typeRef);
            output.Write(" ");
            OutputIdentifier(name);
        }

        private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems = false)
        {
            bool first = true;
            IEnumerator en = expressions.GetEnumerator();
            Indent++;
            while (en.MoveNext())
            {
                if (!first)
                {
                    if (newlineBetweenItems)
                    {
                        ContinueOnNewLine(",");
                    }
                    else
                    {
                        output.Write(", ");
                    }
                }
                else
                {
                    first = false;
                }
                ((ICodeGenerator)this).GenerateCodeFromExpression((CodeExpression)en.Current, output.InnerWriter, options);
            }
            Indent--;
        }

        private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
        {
            bool first = true;
            bool multiline = parameters.Count > ParameterMultilineThreshold;
            if (multiline)
            {
                Indent += 3;
            }
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext())
            {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                if (!first)
                {
                    output.Write(", ");
                }
                else
                {
                    first = false;
                }
                if (multiline)
                {
                    ContinueOnNewLine("");
                }
                GenerateExpression(current);
            }
            if (multiline)
            {
                Indent -= 3;
            }
        }

        private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
        {
            if (typeParameters.Count == 0)
            {
                return;
            }

            output.Write('<');
            bool first = true;
            for (int i = 0; i < typeParameters.Count; i++)
            {
                if (!first)
                {
                    output.Write(", ");
                }
                else
                {
                    first = false;
                }

                if (typeParameters[i].CustomAttributes.Count > 0)
                {
                    GenerateAttributes(typeParameters[i].CustomAttributes, true);
                    output.Write(' ');
                }
                output.Write(typeParameters[i].Name);
            }
            output.Write('>');
        }

        // returns the type name without any array declaration.
        private string GetBaseTypeOutput(CodeTypeReference typeRef)
        {
            string s = typeRef.BaseType;
            if (s.Length == 0)
            {
                return "void";
            }

            string lowerCaseString = s.ToLower(CultureInfo.InvariantCulture).Trim();
            switch (lowerCaseString)
            {
                case "system.int16":
                    s = "short";
                    break;
                case "system.int32":
                    s = "int";
                    break;
                case "system.int64":
                    s = "long";
                    break;
                case "system.string":
                    s = "String";
                    break;
                case "system.object":
                    s = "Object";
                    break;
                case "system.boolean":
                    s = "boolean";
                    break;
                case "system.void":
                    s = "void";
                    break;
                case "system.char":
                    s = "char";
                    break;
                case "system.byte":
                    s = "byte";
                    break;
                case "system.single":
                    s = "float";
                    break;
                case "system.double":
                    s = "double";
                    break;
                default:
                    // replace + with . for nested classes
                    StringBuilder sb = new StringBuilder(s.Length + 10);
                    if ((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0)
                    {
                        sb.Append("global::");
                    }

                    string baseType = typeRef.BaseType;
                    int lastIndex = 0;
                    int currentTypeArgStart = 0;
                    for (int i = 0; i < baseType.Length; i++)
                    {
                        switch (baseType[i])
                        {
                            case '+':
                            case '.':
                                sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex, i - lastIndex)));
                                sb.Append('.');
                                i++;
                                lastIndex = i;
                                break;

                            case '`':
                                sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex, i - lastIndex)));
                                i++; // skip the '
                                int numTypeArgs = 0;
                                while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <= '9')
                                {
                                    numTypeArgs = numTypeArgs * 10 + (baseType[i] - '0');
                                    i++;
                                }

                                GetTypeArgumentsOutput(typeRef.TypeArguments, currentTypeArgStart, numTypeArgs, sb);
                                currentTypeArgStart += numTypeArgs;

                                // Arity can be in the middle of a nested type name, so we might have a . or + after it.
                                // Skip it if so.
                                if (i < baseType.Length && (baseType[i] == '+' || baseType[i] == '.'))
                                {
                                    sb.Append('.');
                                    i++;
                                }

                                lastIndex = i;
                                break;
                        }
                    }

                    if (lastIndex < baseType.Length)
                    {
                        sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));
                    }
                    return sb.ToString();
            }
            return s;
        }

        private string GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
        {
            StringBuilder sb = new StringBuilder(128);
            GetTypeArgumentsOutput(typeArguments, 0, typeArguments.Count, sb);
            return sb.ToString();
        }

        private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
        {
            sb.Append('<');
            bool first = true;
            for (int i = start; i < start + length; i++)
            {
                if (!first)
                {
                    sb.Append(", ");
                }
                else
                {
                    first = false;
                }

                // it's possible that we call GetTypeArgumentsOutput with an empty typeArguments collection. This is the case
                // for open types, so we want to just output the brackets and commas.
                if (i < typeArguments.Count)
                {
                    sb.Append(GetTypeOutput(typeArguments[i]));
                }
            }
            sb.Append('>');
        }

        public string GetTypeOutput(CodeTypeReference typeRef)
        {
            string s = string.Empty;
            CodeTypeReference baseTypeRef = typeRef;
            while (baseTypeRef.ArrayElementType != null)
            {
                baseTypeRef = baseTypeRef.ArrayElementType;
            }
            s += GetBaseTypeOutput(baseTypeRef);

            while (typeRef != null && typeRef.ArrayRank > 0)
            {
                char[] results = new char[typeRef.ArrayRank + 1];
                results[0] = '[';
                results[typeRef.ArrayRank] = ']';
                for (int i = 1; i < typeRef.ArrayRank; i++)
                {
                    results[i] = ',';
                }
                s += new string(results);
                typeRef = typeRef.ArrayElementType;
            }
            return s;
        }

        private void OutputAttributeArgument(CodeAttributeArgument arg)
        {
            if (arg.Name != null && arg.Name.Length > 0)
            {
                OutputIdentifier(arg.Name);
                output.Write("=");
            }
            ((ICodeGenerator)this).GenerateCodeFromExpression(arg.Value, output.InnerWriter, options);
        }

        private void OutputTypeAttributes(CodeTypeDeclaration e)
        {
            if ((e.Attributes & MemberAttributes.New) != 0)
            {
                output.Write("new ");
            }

            TypeAttributes attributes = e.TypeAttributes;
            switch (attributes & TypeAttributes.VisibilityMask)
            {
                case TypeAttributes.Public:
                case TypeAttributes.NestedPublic:
                    output.Write("public ");
                    break;
                case TypeAttributes.NestedPrivate:
                    output.Write("private ");
                    break;
                case TypeAttributes.NestedFamily:
                    output.Write("protected ");
                    break;
            }

            if (e.IsEnum)
            {
                output.Write("enum ");
            }
            else
            {
                switch (attributes & TypeAttributes.ClassSemanticsMask)
                {
                    case TypeAttributes.Class:
                        if (attributes.HasFlag(TypeAttributes.Sealed))
                        {
                            if (attributes.HasFlag(TypeAttributes.Abstract))
                            {
                                output.Write("static ");
                            }
                            else
                            {
                                output.Write("final ");
                            }
                        }
                        else if (attributes.HasFlag(TypeAttributes.Abstract))
                        {
                            output.Write("abstract ");
                        }
                        output.Write("class ");
                        break;
                    case TypeAttributes.Interface:
                        output.Write("interface ");
                        break;
                }
            }
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, bool inLine = false)
        {
            if (attributes.Count == 0)
            {
                return;
            }

            IEnumerator en = attributes.GetEnumerator();
            bool paramArray = false;

            while (en.MoveNext())
            {
                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;

                // params (varargs) must be last parameter to actually compile
                if (current.Name.Equals("system.paramarrayattribute", StringComparison.OrdinalIgnoreCase))
                {
                    paramArray = true;
                    continue;
                }

                output.Write("@");

                if (current.AttributeType != null)
                {
                    output.Write(GetTypeOutput(current.AttributeType));
                }
                if (current.Arguments.Count > 0)
                {
                    output.Write("(");
                    bool firstArg = true;
                    foreach (CodeAttributeArgument arg in current.Arguments)
                    {
                        if (!firstArg)
                        {
                            output.Write(", ");
                        }
                        else
                        {
                            firstArg = false;
                        }
                        OutputAttributeArgument(arg);
                    }
                    output.Write(")");
                }

                if (!inLine)
                {
                    output.WriteLine();
                }
                else
                {
                    output.Write(" ");
                }
            }

            if (paramArray)
            {
                output.Write("params");
                if (!inLine)
                {
                    output.WriteLine();
                }
                else
                {
                    output.Write(" ");
                }
            }
        }
    }
}
